1. Допустим что мы умеем решать задачу про две самые близкие точки.
   Если нет то можно псомотреть решение в лекциях под номером 14.
   И знаем что этот метод называется "Разделяй и властвуй" и знаем что он работает за O(nlogn).
   Ну раз мы знакомы с этим принципом так используем его тут.
   На рисунке 1.1 мы получили следующие периметры P1 и P2.
   И они будут ответами в своих половинах.
   А наш ответ это минимум из этих двух назовём его P.
   Теперь рассмотрим полосу ширины 2*P вокруг разделяющеё прямой.
   (Понимаю на рисунке я не учёл пропорции но думаю это никак не скажется на сути решения)
   Для текущей точки рассмотрим прямоугольную область размера 2*РхР (как в рис 1.2).
   Как в задаче про две точки, по принципу Дирихле, точек будет мало.
   Так как у нас решение аналогично с решением задачи из лекции можем утвреждать что асимптотика будет совпадать тобиш O(nlogn).

2. Ну по алгоритму Грехма мы умеем строить выпуклую облочку для множества точек за O(nlogn).
   (Спойлер эта задача похоже на таску про самые удалённые точки)
   Построим для нашего множества точек выпуклую оболочку.
   Допустим что наш искомый прямоугольник опирается на одну сорону нашей оболочки.
   И пускаем цикл по каждой стороне оболочки и за O(logn) сможем найти самую правую, самую левую и самую верхнию точку относительно текущей стороны.
   И по этим точкам и сороне строим прямоугольник.
   И будем хранить в отдельной переменке минимальный по площади прямоугольник.
   Мы строим оболочку за O(nlogn) и рассматриваем все прямоугольники тоже за O(nlogn).
   И итоговая асимптотика будет тоже O(nlogn).  // пока под вопросом асимптотика построения прямоугольника

3. Снова билдим оболочку для нашего множества точек.
   На это у нас уйдёт как не сложно догодаться O(nlogn) времени.
   Это мы так подготовились к запросам.
   После мы можем на каждый запросной прямой найти перпендикулярный вектор (и это займет константное время).
   За O(logn) сможем найти самую дальную точку для этого вектора и для противополочно направленного вектора.
   И проверить лежат ли эти точки по одну сторону от тякущей прямой или нет.
   Если да то очев что и остальные лежат по одну сторону.
   Так как мы на каждый запрос потратили O(logn) времени и запросов у нас q то итоговаяя асимптотика будет O((n + q)logn).

5. а) Ну k раз бегаем по массиву и каждый раз заполняем каждую ячейку суммой чисел в ячейках из которых конь притопал.
      Конечно будет се делать пока мы не выпадем за пределы шахматного поля.
      Когда перейдём с (k - 1) к k нужно будет рассширить массив и заполнить так же ячейки за пределами игрового поля.
      По итогу просуммируем се и получим итоговый результат.
   б) Пусть M = N^(2) (просто это число буду использованть несколько раз а мне лень писать ещё букавки)
      Ну нам понадобится вектор с M элементами и забить все ячейки нулями кроме одного а именно (N*y0 + x0)тый в нем будем хранить еденичку.
      И Нам ещё понадобится матрица MxM заполненная нулями кроме нескольких ячеек где будет лежать еденички.
      Для удобства вектор обозначу как vec а матрицу как А.
      {момент рукамаханий и рисунков}
      По итогу задача свелась к тому что перемножаем вектор на матрицу возведенную в степень k тобиш vec*A^(k).
      А возведение в степень двойки это у нас O(M^3) или O(N^6) а так как мы умеем возводить в степень быстро и знаем что это занимает O(logk) итераций.
      По итогу будет O((N^(6)) * logk) что от и ожидали.

      