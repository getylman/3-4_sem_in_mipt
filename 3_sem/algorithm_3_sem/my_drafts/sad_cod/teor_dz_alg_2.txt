1. Ну у нас есть N пар.
   Тогда отсортеруем их по разности ai и bi.
   Отсортировать мы должны по невозрастанию.
   Тогда для множества I берём первые k элементов нашего массива пар.
   Тк мы сортируем по невозрастанию то значение функции будет максимально.
   Доп память тут O(1) тк мы работаем только с нашим данным массивом и просто его модифицируем.
   А по времени очевидно O(NlogN) тк мы сортируем наш массив пар.
   


3. Создаем кучу где в корне храним максимум. 
   Будем поддерживать размер кучи <= k.
   Тобиш будем инсертить при условии если размер кучи <= k.
   А если мы уже забили его то будем сравнивать с корнем если число которое мы хотим закинуть меньше корня то инсертим иначе скипаем.
   Ну вот у нас готова куча теперь возьмем минимальный элемент из двух массивов и инсертим в кучу попарные суммы с элементами противоположного массива.
   После мы удаляем этот минимум и повторям алгорим.
   Мы остановимся в тот момент когда первая попарная сумма будет больше корня кучи.
   Доп память O(k)  очевидно почему.
   Время O(klogk).
   Ну логорифм вылезает от того что поле каждого инсерата мы делаем просеивание.
   

4. Для начала отсортеруем массив запросов.
   После для медианы из этого массива ищем kтую порядкову после запускаем партишин для неё.
   Далее рекурсивно повторяем для левой и правой половины запросов.
   По памяти там логорифм тк мы храним стек вызова из-за рекурсии.
   Ассимптотика времени O(n * logm + m).
   Сортировка элементов массива запросов занимает O(m * logm).
   И из-за партишина мы будем спускаться в глубину logm и для каждого ключа следовательно O(n * logm).
   А +m мы просто описываем повторения.   

5. 1.1) k * j + i
       Мы умножаем индекс родителя на ранг кучи для получения индекса элемента до его детей.
       Тобиш индекс элемента после которого находятся k детей jго узла и мы прибавляем i чтоб определить точный индекс нужного нам ребёнка.
   1.2) (i - 1) / k
       Мы вычитаем единицу у индекса ребёнка чтоб обойти ситуацию если индекс ребёнка будет указывать на число которое делится на k без остатка.
       А если после вычита мы получили число кратное k тогда значит i был первым ребёнком и по формуле из задания выше мы подтверждаем что это точно будет родитель.
   2) O(k * h) где h это высота кучи.
      Мы домножаем на k тк мы должны совершить линейный проход чтоб понять к какому ребёнку идти.
      Пусть в куче n элементов тогда это число можно расписать так: n = 1 + k + k ^ 2 + ... + k ^ (h - 2) + c, где с это оставшиеся дети.
      Можно сказать что n <= 1 + k + ... + k ^ (h - 1) = (k ^ h - 1) / (k - 1).
      И преобразовав это всё получаем что высота имеет слудующий вид h = logk(n * (k - 1) + 1) с обруглением вверх. 
      Мы округляем потому что количество элементов в куче не всегда является суммой геом прогрессии. 
   3) не смог представить(
